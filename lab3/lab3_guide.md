# <div align="center"> Не REST едины


## <div align="center"> Intro 

Итак, с теоретической базой (контейнерами) - покончено. Более глубокие знания вы получите в следующем семестре на основах контейнеризации. А сейчас приступаем к архитектурным вопросам.

Продолжим разговор про общение между контейнерами. В прошлой лабораторной вы реализовывали REST-ful API для межконтейнерного взаимодействия и у интересующихся студентов должен был возникнуть вопрос: **А как ещё бывает?**

Задуматься об этом стоило так как часто бывает, что сервисы падают каскадом - один упал, запросы не обрабатывает. Вслед за ним валятся другие сервисы, которые его вызывали - все от того, что они не могут получить ответ на свой запрос. Так по цепочке происходит полный коллапс.

**А бывает так:**
  - Синхронные способы общения - мы делаем вызов и ждем получения ответа.
  - Асинхронные способы общения - мы отправляем сообщение, а ответ придет когда-нибудь потом или он в принципе не предусмотрен.

**Еси конкретнее:**
  - Синхронные способы общения:
    - [REST](https://habr.com/ru/articles/38730/). В чистом виде встречается крайне редко, но в целом - один из самых популярных методов общения между сервисами. При желании можно его заинкостылировать для "асинхронной" работы, но этот случай мы рассматривать не будем. Данные передаются в текстовом формате. Работает поверх HTTP/1.1
    - [RPC](https://habr.com/ru/companies/yandex/articles/484068/) (Удалённый вызов процедур). Самая популярная технология - gRPC (Google RPC). В отличие от REST, данные передаются в бинарном формате Protobuf, используется строгая схема данных, запросы можно передавать "стримингом". Работает поверх HTTP/2.
    - [SOAP](https://ru.wikipedia.org/wiki/SOAP). Если интересно - [почитайте сами](https://habr.com/ru/articles/483204/), но глобально - устаревший.
  - Асинхронные способы общения:
    - [AMQP](https://habr.com/ru/articles/62502/) брокеры. В основе AMQP лежит посредническая модель обмена сообщениями. В этой модели брокер сообщений выступает посредником между издателями и подписчиками. Сообщения сначала публикуются в обменник (exchange) внутри брокера. Обменник, выступая в роли маршрутизатора, перенаправляет эти сообщения в соответствующие очереди согласно своим правилам маршрутизации. [Простенькое сравнение брокеров.](https://www.okbsapr.ru/library/publications/shkola_kzi_chadov_mikhalchenko_2019/)
    - [MQTT](https://cloud.yandex.ru/ru/docs/glossary/mqtt-server) брокеры. Это легковесный протокол обмена сообщениями для публикации/подписки сообщений, на настоящий момент этот протокол является основным стандартом в Интернете Вещей (IoT). [Популярные брокеры](https://habr.com/ru/companies/icl_group/articles/782644/). [Сравнение с AMQP.](https://www.cloudamqp.com/blog/amqp-vs-mqtt.html) Для наших задач - не интерересно, но для общего развития почитать стоит.
    - [Apache Kafka](https://habr.com/ru/companies/selectel/articles/757440/). Использует собственный протокол и в отличии от AMQP и MQTT брокеров - хранит сообщения на диске и изначально разработан для использования в кластерах под большой нагрузкой с высокой отказоустойчивастью. [Сравнение с RabbitMQ.](https://vc.ru/dev/869548-kafka-vs-rabbitmq-chto-nuzhno-znat-analitiku-pro-brokery-soobshcheniy)


Отдельного упоминания заслуживает [GraphQL](https://habr.com/ru/articles/765064/). Это современный подход к построению API, который позволяет клиенту гибко запрашивать нужную структуру данных, а не получать жестко заданные ресурсы как в REST. GraphQL использует систему типов и схему для описания API, что дает возможность автоматически генерировать документацию, валидировать запросы и эффективно кэшировать данные на сервере. В отличие от REST, GraphQL позволяет получать связанные данные из разных источников в одном запросе, экономя количество обращений к серверу, но сегодня не о нём.

**Преимущества и недостатки обмена сообщениями на основе брокера**:
- **Преимущества**
  - Слабая связанность. Для выполнения запроса клиенту нужно лишь отправить сообщение в подходящий канал. Клиенту ничего не известно об экземплярах сервиса.
  - Буферизация сообщений. Брокер буферизирует сообщения до тех пор, пока их не смогут обработать. В протоколах с синхронными запросами/ответами, таких как HTTP, и клиент, и сервис должны быть доступны на протяжении всего обмена данными. Сообщения же накапливаются в очереди, пока потребитель не будет готов их принять. Это означает, что, к примеру, онлайн-магазин может принимать заказы от посетителей, даже если система выполнения заказов слишком медленная или недоступна. Сообщения просто будут ожидать в очереди, пока их не смогут обработать.
  - Явное межпроцессное взаимодействие. Механизмы, основанные на RPC, пытаются сделать так, чтобы обращение к удаленному сервису выглядело словно вызов локальной процедуры. Но законы физики и вероятность частичных отказов делают эти два вида взаимодействия очень разными. Обмен сообщениями делает различия явными, чтобы у разработчиков не возникало ложное чувство безопасности.
- **Недостатки**
  - Потенциальное узкое место производительности. Существует риск того, что брокер сообщений может стать узким местом производительности.
  - Потенциальная единая точка отказа. Крайне важно, чтобы брокер сообщений был высокодоступным, иначе может пострадать надежность системы.
  - Дополнительная сложность в администрировании. Механизм обмена сообщениями — это еще один системный компонент, который нужно устанавливать, конфигурировать и администрировать.

**Типовые ошибки:**
  - **Конкурирующие получатели и порядок следования сообщений.** Представьте, например, что у вас есть три экземпляра сервиса, которые читают из 
одного канала, и producer последовательно публикует события 
Create **Ъ**, Update **Ъ** и Cancell **Ъ** (Где **Ъ**, скажем заказ в интернет - магазине). Примитивная реализация могла бы 
параллельно доставить каждое сообщение своему получателю, что привело бы к ошибке.
  - **Дублирование сообщений.** Ещё одна проблема, которую необходимо решить при обмене сообщениями, связана с дубликатами. В идеале брокер должен доставлять каждое сообщение ровно один раз, но обеспечение таких гарантий обычно оказывается слишком затратным. Вместо этого большинство брокеров обещают доставить сообщение как минимум один раз.Допустим, сервис отказывает после обработки сообщения и обновления базы данных, но перед подтверждением сообщения. Тогда брокер доставит неподтвержденное сообщение повторно — либо тому же сервис, когда он перезапустится, либо реплике сервиса.

Такие проблемы стоит отдельно отслеживать при проектировании системы.


## <div align="center"> Примеры использования

А в этот раз примеров **не будет**. 

Эта лабораторная будет первой в серии из трёх лаб, в которых вы будуте развивать свой проект. Необходимо придумать проект, разработать его архитектуру и утвердить тему. Составляющие сервисы для этой работы будут описаны в конце гайда. Для разработки необходимо будет использовать технику **TDD**. Вы уже работали по этой технике в рамках курса по ООП. Для тестирования кода можно использовать любой фреймворк на ваше усмотрение, а для тестирования API я предлагаю использовать Postman.

## <div align="center"> Postman

Postman - это популярное приложение для тестирования и документирования API. Оно позволяет проводить как ручное тистирование одиночных эндпоинтов, так и автоматическое тестирование всего API. Так же есть функционал для нагрузочного тестирования (скажем эмуляция запросов с определённой переодичностью от 100 пользователей). Для начала советую посмотреть [эту статью на хабре](https://habr.com/ru/companies/maxilect/articles/596789/).

## <div align="center"> Суть работы

Для начала нужно придумать суть проекта. Например, можно взять за основу сервис для управления заказами в интернет-магазине или сервис для математиков-нумерологов, который, скажем вычисляет факториал даты их рождения, прибавляет к нему простое число, ближайшее к году их рождения и делит всё это нацело на их желание съесть бургер от 1 до 100000, чтобы выяснить их счастливое число на сегодня. 

Вобщем простор для фантазии - огромен. **Главное** - итоговый продукт должен содержать в себе
  - Веб страницу с возможностью отправлять запросы к системе.
  - Веб API, как точку входа в систему.
  - Брокер сообщений, как агрегатор запросов.
  - Сервис - обработчик.
  - Базу данных, необходимую для обработки запросов.

Необходимость брокера сообщений, как архитектурного решения в вашем проекте и выбор конкретной технологии необходимо будет обосновать. 

На примере математиков-нумерологов: Брокер необходим т.к. ровно в 9 утра по Махачкале все члены этой секты хотят узнать своё счастливое число, что вызывает значительный рост нагрузки на систему. Было принято решение буферизировать запросы, вместо того, чтобы арендовать более мощный сервер. Для это был использован Apache Kafka т.к. было необходимо обеспечить максимальную отказоустойчивость системы и собирать статистику о их желании съесть бургер, для дальнейшего анализа спецслужбами.

Или же использовать брокер сообщений, как балансировщик нагрузки между несколькими сервисами расчёта счастливого числа.

База данных должна быть подключена к сервису - обработчику. На примере той же секты: Дата рождения сектантов указывается при регистрации и храниться в БД. Изначально в БД должно быть **минимум** 10000 записей.

**Все темы должны быть уникальны!**

После появления основной концепции, её необходимо внести в [гугл таблицу для утверждения](https://docs.google.com/spreadsheets/d/1ZQlkPw7cNIPBLTRwwW5avy3ez7w2EJ4MSgLWcVd3s_Q/edit?usp=sharing) **до 24 марта**.

Учтите, в следующих работах эта система будет расширяться, так что рекомендую сразу разрабатывать продукт, который легко можно будет доработать.
